function M(e,t){const{density:i}=t,n=e-t.value;return[n*t.directionX/i+t.anchorX*t.width,n*t.directionY/i+t.anchorY*t.height]}function C(e){if(e.density<e.minDensity)e.density=e.minDensity;else if(e.density>e.maxDensity)e.density=e.maxDensity}function p(e,t,i,n){const a=e.filter(({maxDensityToShow:r})=>r===void 0?!0:r>=t).map((r)=>[r,Y(r,i)]).filter(([,r])=>r<n),o=new Set;for(let r=a.length-1;r>=0;--r){const[{shy:d=!1,multiply:l},c]=a[r],h=[];if(r)for(let s=c;s<n;s+=l){if(d&&o.has(s))continue;h.push(s),o.add(s)}else for(let s=c+l;s<n;s+=l)if(!d||!o.has(s))h.push(s);a[r][1]=h}return a}function y(e){return Math.abs(e)<=Number.EPSILON}function x(e,t,i,n,a,o){return Math.min(y(i)?1/0:(i>0?a-e:-e)/i,y(n)?1/0:(n>0?o-t:-t)/n)}function P(e,t,i,n){const a=i+e*t;return n===void 0?a:Math.max(n,a)}function X(e,t,i,n){const a=i+e*t;return n===void 0?a:Math.min(n+1,a)}function Y({multiply:e,zeroOffset:t=0},i){return Math.ceil((i-t)/e)*e+t}var N;((n)=>{n[n.DoNothing=0]="DoNothing";n[n.Draw=1]="Draw";n[n.DrawNextFrame=2]="DrawNextFrame"})(N||={});class D{static defaultParams={value:0,redundancy:1,anchorX:0,anchorY:0,directionX:1,directionY:0,density:0.1,minDensity:0.02,maxDensity:100,width:100,height:20};#n;#e;#t=new ResizeObserver(()=>{const e=this.#e;if(!e)return;const t=this.params.pixelRatio??window.devicePixelRatio,{offsetWidth:i,offsetHeight:n}=e,a=this.params.width=i*t,o=this.params.height=n*t,r=this.canvas;if(!r)return;if(r.width=a,r.height=o,r.style.width=`${i}px`,r.style.height=`${n}px`,this.whenResized===1)this.draw();else if(this.whenResized===2)this.drawNextFrame=!0});initStore;initDraw;finalDraw;canvas;params;ticks;whenResized=0;constructor(e,t){const{defaultParams:i}=D;this.params=t?Object.assign({},i,t):{...i},this.ticks=e??[]}get keepSameSizeWith(){return this.#e}set keepSameSizeWith(e){if(this.#e===e)return;if(this.#e)this.#t.unobserve(this.#e);if(this.#e=e,e)this.#t.observe(e)}get drawNextFrame(){return this.#n!==void 0}set drawNextFrame(e){if(e===this.drawNextFrame)return;if(this.#n)cancelAnimationFrame(this.#n),this.#n=void 0;else this.#n=requestAnimationFrame(()=>this.draw())}draw(){this.drawNextFrame=!1;const{params:e,canvas:t}=this;if(C(e),!t)return;const i=t.getContext("2d");if(!i)throw new Error("Failed to get 2d context");const{directionX:n,directionY:a,value:o,redundancy:r,width:d,height:l,density:c}=e,h=e.anchorX*d,s=e.anchorY*l,R=-x(h,s,-n,-a,d,l)-r,S=x(h,s,n,a,d,l)+r,T=P(R,c,o,e.min),w=X(S,c,o,e.max),m=this.initStore?.()??{},u={x:0,y:0,value:0,firstValue:T,lastValue:w};if(this.initDraw?.(i,m,u,e)===null)return;const v=n/c,E=a/c;for(let[{drawCall:f},k]of p(this.ticks,c,T,w))for(let{init:O,each:g,final:L}of Array.isArray(f)?f:[f]){if(O?.(i,m,u,e)===null)continue;for(let F of k){const b=(u.value=F)-o;u.x=b*v+h,u.y=b*E+s,g(i,m,u,e)}L?.(i,m,u,e)}this.finalDraw?.(i,m,u,e)}}export{M as valueToCoord,N as WhenResized,D as LinearTick};

//# debugId=E3E1A83EBAA6C18964756E2164756E21
//# sourceMappingURL=index.js.map
